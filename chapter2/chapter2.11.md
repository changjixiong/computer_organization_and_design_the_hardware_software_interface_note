* 一种原子交换：

  ```
  将寄存器中的一个值和存储器中的一个值相互交换。
  ```

* 过程

  ```
  假设使用存储器中某个单元来表示一个锁变量，0表示解锁，1表示加锁。
  一个处理器尝试加锁，用寄存器中的1与锁单元的值进行交换。交换以后锁单元的新值为1，返回值(锁的原值)如果是1，表示这个锁已被其他处理器占用，否则返回值为0，表示锁是自由的，尝试加锁成功。
  ```

* 关键

  ```
  操作的原子性，即交换操作是不可分割的。
  ```


* 方案

  ```
  指令对，其中第二条指令返回一个表明这对指令是否原子执行的标志值。
  MIPS指令对，一条链接取数(load linked)指令，一条条件存数(store conditional)指令。
  ```

* 过程

  ```
  执行链接取数指令
  执行条件存数指令:保存寄存器的值，如果执行成功则将寄存器的值修改为1，失败则修改为0。
  条件存数指令执行前，锁单元的内容已经改变，条件存数指令执行失败。

  ```

* 实例

  ```
  加锁：
  M为锁单元，线程T1需要加锁
  1.将寄存器R赋值为1。
  2.获取存储器M的值。
  3.1.将R与M中的值交换。
  3.2.交换后R的值为1，M为1，锁单元已经被别的线程加锁，加锁失败，将R赋值为0表示失败。
  3.3.交换后R的值为0，M为1，加锁成功，将R赋值为1表示成功。
  4.如果R为0，回到1
  5.将锁单元的值赋值为寄存器。
  如果有错误导致条件存数指令无法完成则会造成死锁。

  解锁(这个书上没有写，内容基于加锁过程推导)：
  M1为锁单元，线程T1需要解锁
  1.M1为0，未锁定，无法解锁重来。
  2.M1为1,记录寄存器R1中的值0，将R1与M1中的值交换。
  3.交换后R1的值为1，M1为0，解锁成功。
  4.交换后R1的值为0，M1为0，已经被其他线程解锁，解锁失败(通常只有加锁成功的线程才会去解锁，其他线程不解锁)。

  原子比较和交换：

  原子取值后加数：
  ```

* 汇编代码

  ```
  // 存储器(锁单元)的地址由$s1中的值指出
  again: addi $t0, $zero,1		;copy locked value//立即数加法，$t0=$zero+1, $zero恒为0
  	ll		$t1, 0($s1)			;load linked//取链接字 $t1=Memory[$s1+0] 获得锁单元的值
  	sc		$t0, 0($s1)			;store conditional//存条件字Memory[$s1+0]=$t0,$t0=0 or 1
  	beq		$t0, $zero, again	;branch if store fails//if ($t0==$zero) go to again
  	add		$s4, $zero, $t1		;put load value in $s4//$s4=$zero+$t1
  ```

  ​

















