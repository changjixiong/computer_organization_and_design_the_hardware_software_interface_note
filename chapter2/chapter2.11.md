* 一种原子交换：

  ```
  将寄存器中的一个值和存储器中的一个值相互交换。
  ```

* 过程

  ```
  假设使用存储器中某个单元来表示一个锁变量，0表示解锁，1表示加锁。
  一个处理器尝试加锁，用寄存器中的1与锁单元的值进行交换。交换以后锁单元的新值为1，返回值(锁的原值)如果是1，表示这个锁已被其他处理器占用，否则返回值为0，表示锁是自由的，尝试加锁成功。
  ```

* 关键

  ```
  操作的原子性，即交换操作是不可分割的。
  ```


* 方案

  ```
  指令对，其中第二条指令返回一个表明这对指令是否原子执行的标志值。
  MIPS指令对，一条链接取数(load linked)指令，一条条件存数(store conditional)指令。
  ```

* 过程

  ```
  执行链接取数指令
  执行条件存数指令:保存寄存器的值，如果执行成功则将寄存器的值修改为1，失败则修改为0。
  条件存数指令执行前，锁单元的内容已经改变，条件存数指令执行失败。
  ```

* 加锁

  汇编代码

  ```
  // 存储器(锁单元)的地址由$s1中的值指出
  again: addi $t0, $zero,1		;copy locked value//立即数加法，$t0=$zero+1, $zero恒为0
  	ll		$t1, 0($s1)			;load linked//取链接字 $t1=Memory[$s1+0] 获得锁单元的值
  	sc		$t0, 0($s1)			;store conditional//存条件字Memory[$s1+0]=$t0,$t0=0 or 1
  	beq		$t0, $zero, again	;branch if store fails//if ($t0==$zero) go to again
  	add		$s4, $zero, $t1		;put load value in $s4//$s4=$zero+$t1
  ```

  翻译成自然语言

  ```
  1.将寄存器t0赋值为1。
  2.将锁单元s1的值存入寄存器t1。
  3.交换寄存器t0与锁单元s1的值，交换成功(加锁成功)t0为1，交换失败(加锁失败)t0为0。
  4.如果t0的值为0，转到步骤1
  5.将t1的值(锁单元的原值)赋值给寄存器s4。
  ```

* 解锁

  ```
  这个书上没有写，内容基于加锁过程推导：
  M1为锁单元，线程T1需要解锁
  1.M1为0，未锁定，无法解锁重来。
  2.M1为1,记录寄存器R1中的值0，将R1与M1中的值交换。
  3.交换后R1的值为1，M1为0，解锁成功。
  4.交换后R1的值为0，M1为0，已经被其他线程解锁，解锁失败(通常只有加锁成功的线程才会去解锁，其他线程不解锁)。
  ```

  ​

